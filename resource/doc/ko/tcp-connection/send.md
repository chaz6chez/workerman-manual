# send
## 설명:
```php
mixed Connection::send(mixed $data [,$raw = false])
```

클라이언트에 데이터를 전송합니다.

## 매개변수

 ``` $data ```

전송할 데이터입니다. Worker 클래스를 초기화할 때 프로토콜을 지정했다면 프로토콜의 encode 메서드를 자동으로 호출하여 프로토콜 패키징 작업을 완료한 후 클라이언트에 전송합니다.

 ``` $raw ```

원시 데이터를 전송할지 여부로, 기본값은 false이며, 즉 프로토콜의 encode 메서드를 자동으로 호출합니다.

## 반환 값

true - 데이터가 해당 연결의 운영 체제 소켓 전송 버퍼에 성공적으로 기록되었음을 나타냅니다.

null - 데이터가 해당 연결의 응용 계층 전송 버퍼에 기록되었으며, 시스템 소켓 전송 버퍼에 기록을 대기 중임을 나타냅니다.

false - 전송이 실패했음을 나타냅니다. 실패 원인은 클라이언트 연결이 이미 닫혔거나, 해당 연결의 응용 계층 전송 버퍼가 가득 찼을 수 있습니다.

## 주의사항
send가 ```true```를 반환한다고 해서 데이터가 해당 연결의 운영 체제 소켓 전송 버퍼에 성공적으로 기록되어 상대 소켓 수신 버퍼로 성공적으로 전송되었거나, 상대 응용 프로그램이 로컬 소켓 수신 버퍼에서 데이터를 이미 받았다는 것을 의미하지는 않습니다. **하지만 send가 false를 반환하지 않고 네트워크 연결이 유지되며 클라이언트가 정상적으로 수신될 경우, 데이터는 대략적으로 상대방에게 100% 전송된 것으로 간주할 수 있습니다.**

운영 체제는 소켓 전송 버퍼의 데이터를 비동기적으로 대상에게 보내기 때문에 응용 계층은 해당 데이터가 언제 전송이 시작되었는지를 알 수 없으며, 더 나아가 해당 데이터가 성공적으로 전송되었는지를 알 수 없습니다. 이러한 이유 때문에 workerman은 직접적인 메시지 확인 인터페이스를 제공할 수 없습니다.

모든 메시지가 클라이언트에게 정확하게 전달되어야 하는 경우, 비즈니스 로직에 확인 메커니즘을 추가할 수 있습니다. 확인 메커니즘은 비즈니스에 따라 다르며, 동일한 비즈니스의 확인 메커니즘도 여러 가지 방법이 있을 수 있습니다.

예를 들어, 채팅 시스템은 다음과 같은 확인 메커니즘을 사용할 수 있습니다. 각 메시지를 데이터베이스에 저장하고, 각 메시지에는 읽음 여부 필드가 있습니다. 클라이언트가 각 메시지를 수신하면 서버에게 확인 패킷을 보내고, 서버는 해당 메시지를 읽음으로 표시합니다. 클라이언트가 서버에 연결할 때(일반적으로 사용자 로그인 또는 재연결 해제 시), 데이터베이스에서 읽지 않은 메시지가 있는지 확인하고, 있다면 클라이언트에게 전송한 후 클라이언트가 메시지를 수신하면 서버에게 읽음으로 표시합니다. 이렇게 함으로써 각 메시지가 상대방에게 전달되도록 보장할 수 있습니다. 물론 개발자는 자체적인 확인 로직을 사용할 수도 있습니다.

## 예시

```php
use Workerman\Worker;
use Workerman\Connection\TcpConnection;
require_once __DIR__ . '/vendor/autoload.php';

$worker = new Worker('websocket://0.0.0.0:8484');
$worker->onMessage = function(TcpConnection $connection, $data)
{
    // 자동으로 \Workerman\Protocols\Websocket::encode를 호출하여 websocket 프로토콜 데이터를 패키징한 후 전송합니다.
    $connection->send("hello\n");
};
// worker 실행
Worker::runAll();
```
