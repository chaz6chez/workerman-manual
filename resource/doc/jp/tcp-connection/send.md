# send
## 説明:
```php
mixed Connection::send(mixed $data [,$raw = false])
```

クライアントにデータを送信します。

## パラメータ

 ``` $data ```

送信するデータです。Workerクラスの初期化時にプロトコルが指定されている場合、自動的にプロトコルのencodeメソッドが呼び出され、プロトコルのパッケージングが完了してクライアントに送信されます。

 ``` $raw ```
 
生データを送信するかどうかを指定します。つまり、プロトコルのencodeメソッドを呼び出さずにデータをそのまま送信する場合、デフォルトはfalseであり、つまり自動的にプロトコルのencodeメソッドが呼び出されます。

## 戻り値

true：データが接続のオペレーティングシステムのソケット送信バッファに正常に書き込まれたことを示します。

null：データが接続のアプリケーション層送信バッファに書き込まれ、システム層のソケット送信バッファに書き込むのを待っていることを示します。

false：送信に失敗したことを示します。失敗の原因は、クライアント接続がすでに閉じられているか、接続のアプリケーション層送信バッファがいっぱいである可能性があります。

## 注意
sendが```true```を返すと、データが接続のオペレーティングシステムのソケット送信バッファに正常に書き込まれたことを意味し、データが正常に対向ソケットの受信バッファに送信されたことを意味するわけではありません。**ただし、sendがfalseを返さず、ネットワークが切断されず、かつクライアント側が正常に受信している場合、データは基本的に相手に到達できると見なされます。**

ソケット送信バッファのデータは、オペレーティングシステムが対向に非同期で送信するため、オペレーティングシステムはアプリケーション層に対する対応確認機構を提供していません。そのため、**アプリケーション層**は、ソケット送信バッファのデータがいつ送信を開始したのかを知ることはできず、また、ソケット送信バッファのデータが正常に送信されたのかを知ることもできません。これらの理由から、Workermanは直接的なメッセージ確認インターフェースを提供することはできません。

もし、各メッセージがクライアントに届くことを保証したい場合は、確認メカニズムをビジネスロジックに追加することができます。確認メカニズムはビジネスによって異なり、同じビジネスにおいても複数の方法が存在することがあります。

例えば、チャットシステムではこのような確認メカニズムを使用できます。各メッセージをデータベースに保存し、各メッセージに既読フラグを持たせます。クライアントがメッセージを受信するたびに、サーバーに対して確認パケットを送信し、サーバーは対応するメッセージを既読にします。クライアントがサーバーに接続する時（通常はユーザーログインまたは再接続時）、未読のメッセージがあればクライアントに送信し、同様にクライアントがメッセージを受信したらサーバーに既読を通知します。これにより、各メッセージが相手に届くことが保証されます。もちろん、開発者は独自の確認ロジックを使用することもできます。

## 例

```php
use Workerman\Worker;
use Workerman\Connection\TcpConnection;
require_once __DIR__ . '/vendor/autoload.php';

$worker = new Worker('websocket://0.0.0.0:8484');
$worker->onMessage = function(TcpConnection $connection, $data)
{
    // 自動的に\Workerman\Protocols\Websocket::encodeを呼び出してWebSocketプロトコルのデータをパッケージ化して送信します
    $connection->send("hello\n");
};
// workerを実行する
Worker::runAll();
```
