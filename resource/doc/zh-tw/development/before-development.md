# 開發前必讀

使用 WorkerMan 開發應用程式，你需要了解以下內容：

## 一、WorkerMan 開發與一般 PHP 開發的不同之處

除了與 HTTP 協議相關的變數函數無法直接使用外，WorkerMan 開發與一般 PHP 開發並沒有很大不同。

### 1、應用層協議不同
* 一般 PHP 開發一般是基於 HTTP 應用層協議，Web 伺服器已經幫開發者完成了協議的解析
* WorkerMan 支持各種協議，目前內建了 HTTP、WebSocket 等協議。WorkerMan 推薦開發者使用更簡單的自定義協議通訊
* 關於 HTTP 協議開發請參考 [Http 服務部分](../http/request.md)

### 2、請求週期差異
* PHP 在 Web 應用中一次請求過後會釋放所有的變數與資源
* WorkerMan 開發的應用程式在第一次載入解析後便常駐內存，使得類的定義、全域物件、類的靜態成員不會釋放，便於後續重複利用

### 3、注意避免類和常量的重複定義
* 由於 WorkerMan 會快取編譯後的 PHP 檔案，所以要避免多次 require/include 相同的類或者常量的定義檔案。建議使用 require_once/include_once 載入檔案。

### 4、注意單例模式的連線資源的釋放
* 由於 WorkerMan 不會在每次請求後釋放全域物件及類的靜態成員，在資料庫等單例模式中，往往會將資料庫實例（內部包含了一個資料庫 socket 連線）保存在資料庫靜態成員中，使得 WorkerMan 在進程生命週期內都復用這個資料庫 socket 連線。需要注意的是當資料庫伺服器發現某個連線在一定時間內沒有活動後可能會主動關閉 socket 連線，這時再次使用這個資料庫實例時會報錯，（錯誤訊息類似 mysql gone away）。WorkerMan 提供了[資料庫類](../components/workerman-mysql.md)，有中斷重連的功能，開發者可以直接使用。

### 5、注意不要使用 exit、die 出語句
* WorkerMan 運行在 PHP 命令列模式下，當調用 exit、die 退出語句時，會導致當前進程退出。雖然子進程退出後會立刻重新創建一個的相同的子進程繼續服務，但是還是可能對業務產生影響。

### 6、改完程式碼需要重啟服務才能生效
由於 WorkerMan 是常駐內存的，PHP 類即函數的定義載入一次後便常駐內存，不會再次讀取磁碟載入，所以每次修改完業務程式碼需要重啟才能生效。

## 二、需要了解的基本概念

### 1、TCP 傳輸層協議
TCP 是一種面向連接的、可靠的、基於 IP 的傳輸層協議。TCP 傳輸層協議一個重要特點是 TCP 是基於數據流的，客戶端的請求會源源不斷的發送給伺服端，伺服端收到的數據可能不是一個完整的請求，也有可能是多個請求連在一起。這就需要我們在這源源不斷的數據流中區分每個請求的邊界。而應用層協議主要是為請求邊界定義一套規則，避免請求數據混亂。

### 2、應用層協議

應用層協議(application layer protocol)定義了運行在不同端系統上（客戶端、伺服端）的應用程式進程如何相互傳遞報文，例如 HTTP、WebSocket 都屬於應用層協議。例如一個簡單的應用層次協議可以如下```{"module":"user","action":"getInfo","uid":456}\n"```。此協議是以```"\n"```（注意這裡```"\n"```代表的是換行）標記請求結束，消息體是字串。

### 3、短連接

短連接是指通訊雙方有數據交互時，就建立一個連接，數據發送完成後，則斷開此連接，即每次連接只完成一項業務的發送。像網站的 HTTP 服務一般都用短連接。

*短連接應用程式開發可以參考基本開發流程一章*

### 4、長連接

長連接，指在一個連接上可以連續發送多個數據包。

注意：長連接應用必須加[心跳](../faq/heartbeat.md)，否則連接可能由於長時間不活躍而被路由節點防火牆斷開。

長連接多用於操作頻繁，點對點的通訊的情況。每個 TCP 連接都需要三步握手，這需要時間，如果每個操作都是先連接，再操作的話那麼處理速度會降低很多。所以長連接在每個操作完後都不斷開，下次處理時直接發送數據包就 OK 了，不用建立 TCP 連接。例如：資料庫的連接用長連接，如果用短連接頻繁的通訊會造成 socket 錯誤，而且頻繁的 socket 創建也是對資源的浪費。

*當需要主動向客戶端推送數據時，例如聊天類、即時遊戲類、手機推送等應用需要長連接。* 
*長連接應用程式開發可以參考 Gateway/Worker開發流程*

### 5、平滑重啟

一般的重啟的過程是把所有進程全部停止後，再開始創建全新的服務進程。在這個過程中會有一個短暫的時間內是沒有進程對外提供服務的，這就會導致服務暫時不可用，這在高並發時勢必會導致請求失敗。

而平滑重啟則不是一次性的停止所有進程，而是一個進程一個進程的停止，每停止一個進程後馬上重新創建一個新的進程頂替，直到所有舊的進程都被替換為止。

平滑重啟 WorkerMan 可以使用 ```php your_file.php reload``` 命令，能夠做到在不影響服務質量的情況下更新應用程式。

**注意：只有在 on{...} 回調中載入的檔案平滑重啟後才會自動更新，啟動腳本中直接載入的檔案或者寫死的程式碼運行 reload 不會自動更新。**

## 三、區分主進程和子進程
有必要注意下代碼是運行在主進程還是子進程，一般來說在```Worker::runAll();```調用前運行的代碼都是在主進程運行的，onXXX 回調運行的代碼都屬於子進程。注意寫在```Worker::runAll();```後面的代碼永遠不會被執行。

例如下面的代碼
```php
use Workerman\Worker;
use Workerman\Connection\TcpConnection;
require_once __DIR__ . '/vendor/autoload.php';

// 運行在主進程
$tcp_worker = new Worker("tcp://0.0.0.0:2347");
// 賦值過程運行在主進程
$tcp_worker->onMessage = function(TcpConnection $connection, $data)
{
    // 這部分運行在子進程
    $connection->send('hello ' . $data);
};

Worker::runAll();
```

**注意：** 不要在主進程中初始化資料庫、memcache、redis 等連線資源，因為主進程初始化的連線可能會被子進程自動繼承（尤其是使用單例的時候），所有進程都持有同一個連線，服務端通過這個連線返回的數據在多個進程上都可讀，會導致數據錯亂。同樣的，如果任何一個進程關閉連線(例如 daemon 模式運行時主進程會退出導致連線關閉)，都導致所有子進程的連線都被一起關閉，並發生不可預知的錯誤，例如 mysql gone away 錯誤。建議在 onWorkerStart 裡面初始化連線資源。
