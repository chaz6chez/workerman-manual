# فشل الإيقاف

## الظاهرة:
تشغيل ```php start.php stop``` يظهر```stop fail```

### الاحتمال الأول:
الشرط الأساسي هو تشغيل workerman بوضع الإصلاح، حيث يقوم المطور بإرسال إشارة ```SIGSTOP``` إلى workerman عند الضغط على ```ctrl z``` في واجهة المحطة، مما يجعل workerman يدخل إلى الخلفية ويعلق (يتوقف)، مما يجعله غير قادر على الاستجابة لأمر الإيقاف (إشارة ```SIGINT```).

**الحل:**
في واجهة المحطة التي تم بها تشغيل workerman، أدخل ```fg``` (إرسال إشارة ```SIGCONT```) ثم اضغط على Enter، لإعادة workerman إلى الواجهة وقم بالضغط على ```ctrl c``` (إرسال إشارة ```SIGINT```) لإيقاف workerman.

إذا لم يكن بالإمكان إيقافه، حاول تشغيل الأوامر التالية
```
killall -9 php
```
```
ps aux|grep -i workerman|awk '{print $2}'|xargs kill -9
```
### الاحتمال الثاني:
مستخدم Stop ومستخدم تشغيل workerman غير متطابقان، أي أن مستخدم الإيقاف ليس لديه صلاحية إيقاف workerman.

**الحل:**
تبديل إلى مستخدم تشغيل workerman، أو استخدام مستخدم بصلاحيات أعلى لإيقاف workerman.

### الاحتمال الثالث:
تم حذف ملف PID الخاص بعملية العمل الرئيسية في workerman، مما يجعل النصاب غير قادر على العثور على عملية PID، وبالتالي يحدث فشل في الإيقاف.

**الحل:**
قم بحفظ ملف PID في مكان آمن، انظر الدليل [Worker::$pidFile](../worker/pid-file.md).

### الاحتمال الرابع:
عملية العمل الرئيسية في workerman ليست عملية workerman المقابلة.

**الحل:**
افتح ملف PID الخاص بعملية العمل الرئيسية في workerman وشاهد PID العملية الرئيسية، حيث يكون ملف PID افتراضيًا في نفس الدليل الرئيسي لـ Workerman. ثم قم بتشغيل الأمر ```ps aux | grep main_process_pid``` للتحقق مما إذا كانت العملية المقابلة هي عملية workerman. إذا كانت العملية مختلفة، فقد يكون ذلك ناتجًا عن إعادة تشغيل الخادم، مما يجعل PID الذي حفظه workerman قديمًا ويتم استخدامه بالفعل بواسطة عملية أخرى، مما يسبب فشل في الإيقاف. إذا كانت هذه الحالة، فقم بحذف ملف PID.

### الاحتمال الخامس:
تم تثبيت الامتداد grpc، ولكن لم يتم ضبط المتغيرات البيئية ذات الصلة لامتداد grpc، مما يؤدي إلى إنشاء عملية نسخية إضافية عند التشغيل ويتسبب في فشل الإيقاف.

**الحل:**

