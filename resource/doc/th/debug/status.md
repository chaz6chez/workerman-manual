การดูสถานะการทำงาน

การรัน ```php start.php status```
สามารถดูสถานะการทำงานของ WorkerMan ได้ คล้ายกับตัวอย่างด้านล่าง:

```----------------------------------------------GLOBAL STATUS----------------------------------------------------
Workerman version:3.5.13          PHP version:5.5.9-1ubuntu4.24
start time:2018-02-03 11:48:20   run 112 days 2 hours   
load average: 0, 0, 0            event-loop:\Workerman\Events\Event
4 workers       11 processes
worker_name        exit_status      exit_count
ChatBusinessWorker 0                0
ChatGateway        0                0
Register           0                0
WebServer          0                0
----------------------------------------------PROCESS STATUS---------------------------------------------------
pid	memory  listening                worker_name        connections send_fail timers  total_request qps    status
18306	2.25M   none                     ChatBusinessWorker 5           0         0       11            0      [idle]
18307	2.25M   none                     ChatBusinessWorker 5           0         0       8             0      [idle]
18308	2.25M   none                     ChatBusinessWorker 5           0         0       3             0      [idle]
18309	2.25M   none                     ChatBusinessWorker 5           0         0       14            0      [idle]
18310	2M      websocket://0.0.0.0:7272 ChatGateway        8           0         1       31            0      [idle]
18311	2M      websocket://0.0.0.0:7272 ChatGateway        7           0         1       26            0      [idle]
18312	2M      websocket://0.0.0.0:7272 ChatGateway        6           0         1       21            0      [idle]
18313	1.75M   websocket://0.0.0.0:7272 ChatGateway        5           0         1       16            0      [idle]
18314	1.75M   text://0.0.0.0:1236      Register           8           0         0       8             0      [idle]
18315	1.5M    http://0.0.0.0:55151     WebServer          0           0         0       0             0      [idle]
18316	1.5M    http://0.0.0.0:55151     WebServer          0           0         0       0             0      [idle]
----------------------------------------------PROCESS STATUS---------------------------------------------------
Summary	18M     -                        -                  54          0         4       138           0      [Summary]
```
## สถานะทั่วไป

จากหัวข้อนี้เราสามารถเห็นได้ว่า

เวอร์ชันของ WorkerMan ```version:3.5.13```

เวลาเริ่มต้น ```2018-02-03 11:48:20``` ได้เรียกใช้เป็นเวลา ```run 112 days 2 hours```

โหลดเซิร์ฟเวอร์ ```load average: 0, 0, 0``` ตามลำดับ ภายใน 1 นาที 5 นาที และ 15 นาที

การใช้งานไลบรารีเหตุการณ์ IO ```event-loop:\Workerman\Events\Event```

 ```4 workers``` (3 ชนิดของกระบวนการ รวมถึง ChatGateway, ChatBusinessWorker, กระบวนการ Register, และ กระบวนการ WebServer)

 ```11 processes``` (รวม 11 กระบวนการ)

 ```worker_name``` (ชื่อของ worker กระบวนการ)

 ```exit_status``` (รหัสสถานะการออกจากกระบวนการ)

 ```exit_count``` (จำนวนครั้งที่การออกจากกระบวนการด้วยรหัสสถานะนั้น)

ทั่วไปๆ exit_status ค่าเท่ากับ 0 แสดงว่าการออกจากโดยปกติ ถ้ามีค่าอื่นๆ แสดงว่ากระบวนการออกจากโดยผิดปกติ และจะเกิดข้อผิดพลาดที่คล้ายกับ ```WORKER EXIT UNEXPECTED``` ข้อความผิดพลาดจะถูกระบุไปยังไฟล์ที่ระบุไว้ที่ [Worker::logFile](worker/log-file.md)

**exit_status ที่พบบ่อยและความหมายของมันคือดังนี้:**

* 0: แสดงถึงการออกโดยปกติ การรีโหลด restart ทำให้ค่า exit code เป็น 0 เป็นปกติ โปรดทราบว่าการใช้คำสั่ง exit หรือ die ในโปรแกรมยังสามารถทำให้ค่า exit code เป็น 0 และพลิกพลาดไปยัง ```WORKER EXIT UNEXPECTED``` อีกด้วย ใน Workerman ไม่อนุญาตให้โค้ดธุรกิจเรียกใช้ exit หรือ die ด้วย
* 9: การออกที่มีค่า exit code เท่ากับ 9 หมายความว่ากระบวนการถูกฆาตกราการแสร็ง SIGKILL ส่งแล้ว หนังสือที่ออกมีเป็นหลักที่จะเกิดในกรณีที่การหยุดและการรีโหลดได้ทำลายหาสาเหตุเพราะกระบวนการย่อยไม่ตอบสนองต่อสัญญาณรีโหลดจากกระบวนการหลักที่กำหนดไว้เวลา (เช่น mysql, curl และอื่นๆที่ลดเวลาหนังสือหลักหรือลูปไร้ทิศที่ระเบียงอื่นๆ) ถูกฆาตกราการขังให้แตรร้ายได้ โปรดทราบว่าการใช้คำสั่งkill ใน command line บนลินุกซ์ที่ทำภายการส่งสัญญาณฆาตกราการไปยังกระบวนการย่อยยังสามารถทำให้ค่า exit code นี้เป็นไปได้
* 11: การหลักของ PHP ทำการ Core Dump จำนวนการออกแถวของค่า exit code มักจะเกิดขึ้นเพราะการใช้ภายนอกลอยที่ไม่เมื่อก่อสามารถทำให้ค่า exit code เป็นและก่อให้เหตุการณ์ให้บริดทันในขณะสิ่งเดียวกันน้อยมากคือหลัก PHP ซึ่งจำเป็นต้องทำการปรับรุงเป็นโจทย์
* 65280: สาเหตุที่ทำให้ค่า exit code เป็นเชร้งได้จากความผิดในโค้ดธุรกิจ เช่นว่าการเรียกใช้ฟังก์ชันที่ไม่ได้เป็นจริง ข้อผิดพลาดในไวยากรณ์ฯ ข้อผิดพลาดแต่ละแถวของคอร์ที่ถูกระบุไปยังไฟล์ที่ระบุไว้ที่ [Worker::logFile](worker/log-file.md) หรือ สามารถจะหาได้ในไฟล์ที่ระบุเป็น error_log ใน [php.ini](https://php.net/manual/zh/ini.list.php)
* 64000: สาเหตุที่ทำให้ค่า exit code เป็น 64000 คือโค้ดธุรกิจที่ทำให้เกิดขึ้นคำสั่งเป็นฉายที่คิดตั้ง แต่กมัดตามนั้นพาดให้กระบวนการออกไป ถ้า Workerman ถูกเรียกใข้โดยการรันที่หลักให้กระบวนการออกไปการทำงานที่มีเฉพาะระบบการแฟ้มของการเรียกใช้ในสถานการณ์ออกที่กําหนดไว้ จะดำเนินการจดบันทีการเรียก stack ข้อผิดพลาดที่เป็นเรื่องสราดล้าง ถ้า Workerman เป็นโหมด debug แก้ไขเวลาเกิดขึ้นถึงดมีการprinterstack จนวันเทิก หรือ Workerman เป็น demon การกระตือรูปลกทไฟล์ที่ระบุไว้ที่ [Worker::stdoutFile](worker/stdout-file.md)
## สถานะขั้นตอน

pid: ไอดีของขั้นตอน

memory: ข้อมูลที่ใช้ในปัจจุบันของขั้นตอน (ไม่รวมถึงหน่วยความจำที่ใช้โดยไฟล์ที่สามารถติดตั้งของ PHP)

listening: โปรโตคอลของระดับการส่งถาพและที่อยู่ IP ที่กำลังฟัง หากไม่ได้ฟังที่พอร์ตใด ๆ ก็จะแสดง none ดูที่ [Worker class's constructor](worker/construct.md)

worker_name: ชื่อบริการที่ขั้นตอนกำลังทำงาน ดูที่ [Worker class's name property](worker/name.md)

connections: จำนวนของหน่วยการเชื่อมต่อ TCP ที่ขั้นตอนกำลังทำงานอยู่ หน่วยการเชื่อมต่อรวมถึงตัวอย่างของการเชื่อมต่อ TcpConnection และ AsyncTcpConnection จำนวนนี้คือค่าที่เป็นเวลาจริง ไม่ใช่ค่าสะสม โปรดทราบ: เมื่อตัวอย่างของการเชื่อมต่อถูกเรียกใช้งาน close หลังจากนั้นถ้าจำนวนนับไม่ลดลงตามประกาศอาจเนื่องจากโค้ดธุรกิจเซฟเจ็คเชื่อมต่อนั้น ทำให้ตัวอย่างการเชื่อมต่อนี้ไม่สามารถทำลายได้

total_request: บ่งชี้ว่าขั้นตอนเริ่มต้นที่ถึงปัจจุบันรับข้อความหลายๆ รีเควสบ่งนี้ไม่เพียงแต่รวมถึงการร้องขอลูกค้า ยังรวมถึงการร้องขอภายในของ Workerman เช่น การร้องขอการสื่อสารระหว่าง Gateway และ BusinessWorker ภายในโครงการ GatewayWorker. ค่านี้คือค่าสะสม

send_fail: จำนวนครั้งที่ขั้นตอนให้ข้อมูลไปยังลูกค้าไม่สำเร็จ หากมีเหตุผลความล้มเหลวมักเกิดจากการตัดการเชื่อมต่อของลูกค้า รายการนี้ไม่เท่ากับ 0 ส่วนมากจำเป็นเกี่ยวข้องกับสถานะปกติ ดูที่ [เกี่ยวกับสถานะการส่งล้มเหลว](../faq/about-send-fail.md) ค่านี้คือค่าสะสม

timers: จำนวนของตัวกระแสมารที่งานอยู่ (ไม่รวมถึงตัวกระแสที่ถูกลบและตัวกระแสครั้งเดียวที่ถูกทำลายแล้ว) โปรดทราบ: คุณลัมงานเหล่านี้ต้องการเวอร์ชัน workerman >= 3.4.7 ค่านี้คือค่าที่เป็นเวลาจริง ไม่ใช่ค่าสะสม

qps: จำนวนของระบบปัจจุบันที่ได้รับของข้อมูลรีเควสต่อลูกค้าต่อวินาที โปรดทราบ: ในขณะที่ทำงานเสถียรจะเพิ่ม -d นี้จึงจะนับรายการนี้ มิฉะนั้นจะแสดง 0 รายการนี้ต้องการเวอร์ชัน workerman >= 3.5.2 ค่านี้คือค่าที่เป็นเวลาจริง ไม่ใช่ค่าสะสม

status: สถานะขั้นตอน หากเป็น idle แสดงว่างานว่าง หากเป็น busy แสดงว่างานไม่ว่าง โปรดทราบ: หากขั้นตอนอยู่ในสถานะ busy ในขณะทำงานสั้น ๆ นี้เป็นสถานะปกติ หากขั้นตอนอยู่ในสถานะ busy อย่างต่อเนื่บก็อาจได้ระเบียงไปที่ขึ้นได้ทำการบล็อคธุรกิจหรือการวนซ้ำที่หักกะ เป็นไปได้ต้องตรวจสอบโดยดูที่ [ขั้นตอนที่ไม่ว่าง](busy-process.md) โปรดทราบ: คุณลัมงานเหล่านี้ต้องการเวอร์ชัน workerman >= 3.5.0
## หลักการ
หลังจากที่สคริปต์ status ทำงานเสร็จ กระบวนการหลักจะส่งสัญญาณ ```SIGUSR2``` ไปยังกระบวนการ worker ทั้งหมด จากนั้นสคริปต์ status จะเข้าสู่ช่วงเวลาการพักเพื่อรอผลลัพธ์ของสถานะของกระบวนการ worker ทุกตัว ในขณะที่กระบวนการ worker ที่ว่างเวลาได้รับสัญญาณ ```SIGUSR2``` จะทำการเขียนสถานะของตัวเอง (เช่น จำนวนการเชื่อมต่อ จำนวนคำขอ ฯลฯ) ลงในไฟล์ดิสก์ที่เฉพาะเจาะจง ในขณะที่กระบวนการ worker ที่กำลังประมวลผลโลจิกธุรกิจจะรอจนกว่าโลจิกธุรกิจจะเสร็จสิ้นก่อนที่จะทำการเขียนสถานะของตัวเอง หลังจากที่สคริปต์ status หยุดพักสักครู่ จะเริ่มอ่านไฟล์สถานะที่อยู่ในดิสก์ และแสดงผลลัพธ์บนหน้าจอควบคู่ด้วย

## ข้อควรทราบ
เมื่อทำการเรียกใช้ status อาจพบว่ามีกระบวนการบางตัวที่แสดงสถานะ busy มีเหตุผลเนื่องจากกระบวนการกำลังมีงานที่ต้องทำ (เช่น การดำเนินการทางธุรกิจที่ถูกบล็อกเป็นเวลานานในการทำสำหรับคำขอ curl หรือการร้องขอฐานข้อมูล เป็นต้น) และไม่สามารถรายงานสถานะได้ทำให้แสดงสถานะเป็น busy

เมื่อพบปัญหาดังกล่าวจะต้องตรวจสอบรหัสธุรกิจเพื่อดูว่าที่ทำให้เกิดการบล็อกนานนับโลจิกทางธุรกิจ และประเมินระยะเวลาที่ถูกบล็อกว่าตรงตามที่คาดหวังหรือไม่ หากไม่ตรงตามที่คาดหวังจะต้องตรวจสอบรหัสธุรกิจตาม[การตรวจสอบกระบวนการที่ไม่ว่าง](busy-process.md)
