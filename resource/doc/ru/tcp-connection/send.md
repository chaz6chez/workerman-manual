# send
## Описание:
```php
mixed Connection::send(mixed $data [,$raw = false])
```

Отправляет данные клиенту.

## Параметры

 ``` $data ```

Данные, которые нужно отправить. Если протокол был указан при инициализации класса Worker, то будет автоматически вызван метод encode протокола для упаковки данных и их отправки клиенту.

 ``` $raw ```

Флаг отправки сырых данных, то есть без вызова метода encode протокола. По умолчанию false, что означает автоматический вызов метода encode протокола.

## Возвращаемое значение

true - данные успешно записаны в буфер отправки сокета этого соединения на уровне операционной системы

null - данные записаны в буфер отправки на уровне прикладной программы и ожидают записи в буфер отправки сокета на уровне системы

false - отправка не удалась, причины могут быть закрытие соединения с клиентом или переполнение буфера отправки на уровне прикладной программы

## Примечание
Возвращение ```true```, это только означает, что данные успешно записаны в буфер отправки сокета этого соединения на уровне операционной системы и не означает успешной отправки данных на буфер приема сокета на другой стороне и даже не означает успешного прочтения данных приложением с буфера приема сокета. **Однако, если send не вернул false, и сеть не разорвана, и клиент успешно получает данные, то можно почти на 100% быть уверенным, что данные достигли адресата.**

Поскольку данные в буфере отправки сокета асинхронно передаются операционной системой адресату, и операционная система не предоставляет механизма подтверждения для прикладной программы, **прикладная программа** не может узнать, когда данные из буфера отправки сокета начинают передаваться, а также не может узнать, была ли успешной отправка данных из буфера отправки сокета. Из-за этих причин Workerman не может предоставлять прямой интерфейс для подтверждения доставки сообщений.

Если необходимо гарантировать доставку каждого сообщения клиенту, можно добавить механизм подтверждения на уровне бизнес-логики. Механизм подтверждения может отличаться в зависимости от конкретной бизнес-логики, и даже одна и та же бизнес-логика может иметь несколько способов подтверждения.

Например, для чат-системы можно использовать механизм подтверждения следующим образом. Каждое сообщение сохраняется в базе данных, и у каждого сообщения есть поле, которое показывает, было ли сообщение прочитано. При получении каждого сообщения клиент отправляет серверу подтверждение, что сообщение было прочитано. Сервер устанавливает соответствующее сообщение как прочитанное. Когда клиент соединяется с сервером (обычно при входе пользователя или повторном подключении), сервер проверяет, есть ли непрочитанные сообщения в базе данных, и, если они есть, отправляет их клиенту. Клиент также отправляет серверу подтверждение прочтения сообщения. Таким образом можно гарантировать, что каждое сообщение будет доставлено. Конечно, разработчик может использовать собственный механизм подтверждения в зависимости от своей бизнес-логики.



## Пример

```php
use Workerman\Worker;
use Workerman\Connection\TcpConnection;
require_once __DIR__ . '/vendor/autoload.php';

$worker = new Worker('websocket://0.0.0.0:8484');
$worker->onMessage = function(TcpConnection $connection, $data)
{
    // автоматически вызывает \Workerman\Protocols\Websocket::encode для упаковки данных в протокол Websocket и отправки
    $connection->send("hello\n");
};
// запуск worker
Worker::runAll();
```
